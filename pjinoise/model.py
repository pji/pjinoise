"""
model
~~~~~

Data objects to used to construct an image.


Basic Usage
===========
The objects in this module provide the basic structure for how images
are constructed using the pjinoise module. In general, the following
are true:

*   Source objects (pjinoise.sources) create the initial raw image
    data.
*   Operations (pjinoise.operations) determine how two sets of image
    data are blended into a single set of image data.
*   Layer objects (model.Layer) link source objects to operations and
    set the order in which the image data from the sources are blended.
*   Image objects (model.Image) link the image's layer(s) with the
    information for how it should be saved to disk as an image or
    video file.

"""
import typing as t

from pjinoise import filters as f
from pjinoise import operations as op
from pjinoise import sources as s
from pjinoise.base import Serializable


# Defined types.
# The typing for Layers gets complex. These types are used in the
# signatures to try and keep it more readable.
_Deserialized = t.Union[Serializable, t.Sequence[Serializable]]
_Source = t.Union[s.ValueSource, 'Layer']
_SourceSequence = t.Union[_Source, t.Sequence[_Source]]
_Serialized = t.Union[t.Dict[str, t.Any], t.Sequence[t.Dict[str, t.Any]]]
_FilterParam = t.Union[None, t.Sequence[f.Filter], _Serialized]


# Classes.
class Layer(Serializable):
    """A layer of image data to blend with other layers.

    :param source: The image source(s) used to create the image data
        of the layer. Images sources can include Layer objects, so
        Layers can be nested. It can also include sequences of Layer
        objects, that will be blended together to create the image
        data.
    :param blend: The blending operation used to blend this layer into
        the image.
    :param blend_amount: (Optional.) How much this layer's blend should
        impact the overall image. It's equivalent to opacity. The value
        is a percentage in the range 0 <= x <= 1. The default value is
        one.
    :param location: (Optional.) The amount to offset the generation
        of image data from the layer's source(s). This is passed to
        the source(s) as the location parameter to their fill methods.
        The default value is no offset.
    :param filters: (Optional.) A list of filter objects to run on the
        image data generated by the source(s). The default value is
        no filters.
    :param mask: (Optional.) The image source(s) used to create an
        opacity mask for the layer. The default value results in a
        fully opaque mask.
    :param mask_filters: (Optional.) A list of filter objects to run
        on the image data of the opacity mask. The default value is
        no filters.
    :return: A :class:Layer object.
    :rtype: pjinoise.model.Layer

    Usage::

        >>> from pjinoise import operations as op
        >>> from pjinoise import sources as s
        >>>
        >>> layer = Layer(s.Solid(.5), op.replace)
        >>> layer                                       #doctest: +ELLIPSIS
        Layer(source={'color'...blend_amount=1)

    """
    def __init__(self,
                 source: t.Union[_SourceSequence, _Serialized],
                 blend: t.Union[str, t.Callable],
                 blend_amount: float = 1,
                 location: t.Sequence[int] = (0, 0, 0),
                 filters: _FilterParam = None,
                 mask: t.Union[None, _SourceSequence, _Serialized] = None,
                 mask_filters: _FilterParam = None) -> None:
        # Attributes for generating the image data.
        self.source = self._deserialize_obj(source)
        self.filters = self._deserialize_obj(filters)
        self.location = location

        # Attributes for generating the layer mask.
        self.mask = self._deserialize_obj(mask)
        self.mask_filters = self._deserialize_obj(mask_filters)

        # Attributes for setting up the layer blend.
        if isinstance(blend, str):
            blend = op.registered_ops[blend]
        self.blend = blend
        self.blend_amount = blend_amount

    # Public methods.
    def asdict(self) -> dict:
        """Serialize the object to a dictionary."""
        attrs = super().asdict()
        attrs['source'] = self._serialize_object(attrs['source'])
        attrs['mask'] = self._serialize_object(attrs['mask'])
        attrs['filters'] = self._serialize_object(self.filters)
        attrs['mask_filters'] = self._serialize_object(self.mask_filters)
        attrs['blend'] = op.get_regname_for_function(attrs['blend'])
        del attrs['type']
        return attrs

    # Private methods.
    def _deserialize_obj(self, value: _Serialized) -> _Deserialized:
        if not value:
            return None
        if isinstance(value, Serializable):
            return value
        if isinstance(value, t.Sequence):
            return [self._deserialize_obj(item) for item in value]
        if 'type' in value:
            try:
                return s.deserialize_source(value)
            except KeyError:
                return f.deserialize_filter(value)
        return self.__class__(**value)

    def _serialize_object(self, obj) -> _Serialized:
        if not obj:
            return None
        if isinstance(obj, t.Sequence):
            return tuple(self._serialize_object(item) for item in obj)
        return obj.asdict()


class Image(Serializable):
    """An image to create and save to file.

    :param source: The layer(s) or source(s) that will make up the
        image.
    :param size: The size in pixels of the final image. The order
        of the dimensions is Z, Y, X, which is the reverse of the
        usual way to write them. This allows each frame of an
        animation to be stored as a plane in the array storing the
        data. This also allows anything that processes the array,
        such as printing it for debugging, to handle the rows of
        pixels as rows and the columns of pixels as columns.
    :param filename: The name of the file the data will be
        saved to.
    :param format: The file format of the destination file. Allowed
        options are defined by pjinoise.constants.SUPPORTED_FORMATS.
    :param mode: The color mode of the destination file. This is a
        mode as defined by the PIL library. Valid values can be found
        here: https://pillow.readthedocs.io/en/stable/handbook/concepts.html
    :param framerate: (Optional.) If the image is an animation, this
        sets the frame rate of that animation.
    :return: A :class:Image object.
    :rtype: pjinoise.model.Image

    Usage::

        >>> from pjinoise import model as m
        >>> from pjinoise import operations as op
        >>> from pjinoise import sources as s
        >>> layer = m.Layer(s.Solid(.5), op.replace)
        >>> kwargs = {
        ...     'source': layer,
        ...     'size': (1, 720, 1280),
        ...     'filename': 'work.jpg',
        ...     'format': 'JPEG',
        ...     'mode': 'RGB',
        ... }
        >>> image = m.Image(**kwargs)
        >>> image                                       #doctest: +ELLIPSIS
        Image(size=(1, 720, 1280),...'blend_amount': 1})

    """
    def __init__(self,
                 source: t.Union[_SourceSequence, _Serialized],
                 size: t.Sequence[int],
                 filename: str,
                 format: str,
                 mode: str,
                 framerate: t.Union[None, float] = None) -> None:
        self.source = source
        self.size = size
        self.filename = filename
        self.format = format
        self.mode = mode
        self.framerate = framerate

    @property
    def source(self) -> _Source:
        return self._source

    @source.setter
    def source(self, value) -> None:
        self._source = self._process_source(value)

    # Public methods.
    def asdict(self) -> dict:
        """Serialize the object to a dictionary."""
        source = self._serialize_object(self._source)
        attrs = super().asdict()
        attrs['source'] = source
        del attrs['type']
        return attrs

    def count_sources(self) -> int:
        """Return the number of ValueSources contained by the Image."""
        return count_sources(self.source)

    # Private methods.
    def _process_source(self, value) -> t.Union[Layer, t.Sequence[Layer]]:
        # If passed a sequence, process recursively.
        if isinstance(value, t.Sequence):
            return tuple(self._process_source(item) for item in value)

        # If passed a valid object, return it.
        if isinstance(value, Layer):
            return value

        # Otherwise, assume it's a serialized Layer, deserialize, and return.
        return Layer(**value)

    def _serialize_object(self, obj) -> _Serialized:
        if not obj:
            return None
        if isinstance(obj, t.Sequence):
            return tuple(self._serialize_object(item) for item in obj)
        return obj.asdict()


# Utility functions.
def count_sources(obj: t.Union[_Source, t.Sequence[Layer]]) -> int:
    """Find the number of ValueSources contained in the object."""
    if isinstance(obj, t.Sequence):
        counts = [count_sources(item) for item in obj]
        return sum(counts)
    if isinstance(obj, Layer):
        return count_sources(obj.source) + count_sources(obj.mask)
    if isinstance(obj, s.ValueSource):
        return 1
    if obj is None:
        return 0
    else:
        msg = f'Unexpected type in Image: {obj.__class__.__name__}'
        raise TypeError(msg)


if __name__ == '__main__':
    import doctest
    doctest.testmod()
