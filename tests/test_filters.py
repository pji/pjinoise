"""
test_filters
~~~~~~~~~~~~

Unit tests for the pjinoise.filters module.
"""
import unittest as ut
from typing import List

import numpy as np
from PIL import Image

from pjinoise import filters
from pjinoise.common import grayscale_to_ints_list, print_array
from pjinoise.constants import X, Y, Z


# Utility function.
def test_color_filter_process(filter: filters.ForLayer,
                              a: list = None) -> List:
    """Perform the common unit test on the process method of a filter
    that converts a grayscale image to color.
    """
    if a is None:
        a = [
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
        ]
    a = np.array(a, dtype=float)
    a = a / 0xff
    result = filter.process(a)
    return result.tolist()


def test_filter_process(filter: filters.ForLayer, a: list = None) -> List:
    """Parform the common unit test on the process method of a filter
    that takes an returns a pjinoise grayscale image.
    """
    if a is None:
        a = [
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
        ]
    a = np.array(a, dtype=float)
    a = a / 0xff
    result = filter.process(a)
    return grayscale_to_ints_list(result)


# Class tests.
class ClassTestCase(ut.TestCase):
    def test_create_from_command_string(self):
        """Given the name of a filter and its parameters as a
        comma delimited string, filters.make_filter should return
        an initialized Filter object of the correct type.
        """
        exp_super = filters.ForLayer
        exp_cls = filters.Rotate90
        exp_param = 'r'

        direction = 'r'
        act = filters.make_filter('Rotate90', ('r',))
        act_param = act.direction

        self.assertIsInstance(act, exp_super)
        self.assertIsInstance(act, exp_cls)
        self.assertEqual(exp_param, act_param)


# Decorator tests.
class DecoratorTestCase(ut.TestCase):
    def test_channeled_filter(self):
        """Given image data in a multiple channel color space, like
        RGB, process each channel of the image separately, then
        recombine into a single image. This is used to allow filters
        that can only process a single channel (grayscale) to
        process multiple channel images.
        """
        # Expected values.
        exp = [
            [
                [[0x00, 0x40,], [0x40, 0x7f], [0x7f, 0x00],],
                [[0x00, 0x40,], [0x40, 0x7f], [0x7f, 0x00],],
                [[0x00, 0x40,], [0x40, 0x7f], [0x7f, 0x00],],
            ],
            [
                [[0x00, 0x40,], [0x40, 0x7f], [0x7f, 0x00],],
                [[0x00, 0x40,], [0x40, 0x7f], [0x7f, 0x00],],
                [[0x00, 0x40,], [0x40, 0x7f], [0x7f, 0x00],],
            ],
        ]

        # Set up test data and state.
        a = np.array([
            [
                [[0x00, 0x80,], [0x80, 0xff], [0xff, 0x00],],
                [[0x00, 0x80,], [0x80, 0xff], [0xff, 0x00],],
                [[0x00, 0x80,], [0x80, 0xff], [0xff, 0x00],],
            ],
            [
                [[0x00, 0x80,], [0x80, 0xff], [0xff, 0x00],],
                [[0x00, 0x80,], [0x80, 0xff], [0xff, 0x00],],
                [[0x00, 0x80,], [0x80, 0xff], [0xff, 0x00],],
            ],
        ], dtype=np.uint8)

        class Filter(filters.ForLayer):
            @filters.channeled
            def process(self, a):
                if len(a.shape) != 3:
                    raise TypeError('Array not channeled.')
                return a // 2

        f = Filter()

        # Run test.
        result = f.process(a)

        # Extract actual result from test.
        act = result.tolist()

        # Determine if test passed.
        self.assertListEqual(exp, act)


# Layer filter tests.
class BoxBlurTestCase(ut.TestCase):
    def test_boxblur_process(self):
        """Given an image, perform a box blur on the image.
        """
        exp = [
            [
                [0x4d, 0x53, 0x66, 0x86, 0xa6, 0xc1, 0xd2, 0xe0, 0xe6],
                [0x53, 0x5a, 0x6d, 0x8d, 0xaa, 0xc2, 0xd0, 0xdc, 0xe0],
                [0x66, 0x6d, 0x80, 0x9d, 0xb6, 0xc6, 0xcd, 0xd0, 0xd2],
                [0x86, 0x8d, 0x9d, 0xb6, 0xc6, 0xcd, 0xc6, 0xc2, 0xc1],
                [0xa6, 0xaa, 0xb6, 0xc6, 0xcd, 0xc6, 0xb6, 0xaa, 0xa6],
                [0xc1, 0xc2, 0xc6, 0xcd, 0xc6, 0xb6, 0x9d, 0x8d, 0x86],
                [0xd2, 0xd0, 0xcd, 0xc6, 0xb6, 0x9d, 0x80, 0x6d, 0x66],
                [0xe0, 0xdc, 0xd0, 0xc2, 0xaa, 0x8d, 0x6d, 0x5a, 0x53],
                [0xe6, 0xe0, 0xd2, 0xc1, 0xa6, 0x86, 0x66, 0x53, 0x4d],
            ],
            [
                [0x4d, 0x53, 0x66, 0x86, 0xa6, 0xc1, 0xd2, 0xe0, 0xe6],
                [0x53, 0x5a, 0x6d, 0x8d, 0xaa, 0xc2, 0xd0, 0xdc, 0xe0],
                [0x66, 0x6d, 0x80, 0x9d, 0xb6, 0xc6, 0xcd, 0xd0, 0xd2],
                [0x86, 0x8d, 0x9d, 0xb6, 0xc6, 0xcd, 0xc6, 0xc2, 0xc1],
                [0xa6, 0xaa, 0xb6, 0xc6, 0xcd, 0xc6, 0xb6, 0xaa, 0xa6],
                [0xc1, 0xc2, 0xc6, 0xcd, 0xc6, 0xb6, 0x9d, 0x8d, 0x86],
                [0xd2, 0xd0, 0xcd, 0xc6, 0xb6, 0x9d, 0x80, 0x6d, 0x66],
                [0xe0, 0xdc, 0xd0, 0xc2, 0xaa, 0x8d, 0x6d, 0x5a, 0x53],
                [0xe6, 0xe0, 0xd2, 0xc1, 0xa6, 0x86, 0x66, 0x53, 0x4d],
            ],
        ]
        kwargs = {
            'box_size': 5,
        }
        filter = filters.BoxBlur(**kwargs)
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class ColorTestCase(ut.TestCase):
    def test_color_process_by_colorkey(self):
        """Given an image, colorize the image.
        """
        self.maxDiff = None
        exp = [
            [
                [
                    [0x00, 0x00, 0x00],
                    [0x00, 0x15, 0x20],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                ],
                [
                    [0x00, 0x15, 0x20],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                ],
                [
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                ],
                [
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                ],
                [
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                ],
                [
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                ],
                [
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x2a, 0x40],
                ],
                [
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x15, 0x20],
                ],
                [
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x15, 0x20],
                    [0x00, 0x00, 0x00],
                ],
            ],
            [
                [
                    [0x00, 0x00, 0x00],
                    [0x00, 0x15, 0x20],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                ],
                [
                    [0x00, 0x15, 0x20],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                ],
                [
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                ],
                [
                    [0x00, 0x40, 0x60],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                ],
                [
                    [0x00, 0x55, 0x80],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                ],
                [
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                ],
                [
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x2a, 0x40],
                ],
                [
                    [0x00, 0x95, 0xe0],
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x15, 0x20],
                ],
                [
                    [0x00, 0xaa, 0xff],
                    [0x00, 0x95, 0xe0],
                    [0x00, 0x80, 0xc0],
                    [0x00, 0x6a, 0xa0],
                    [0x00, 0x55, 0x80],
                    [0x00, 0x40, 0x60],
                    [0x00, 0x2a, 0x40],
                    [0x00, 0x15, 0x20],
                    [0x00, 0x00, 0x00],
                ],
            ],
        ]
        kwargs = {
            'colorkey': 'b',
        }
        filter = filters.Color(**kwargs)
        act = test_color_filter_process(filter)
        self.assertListEqual(exp, act)


class CurveTestCase(ut.TestCase):
    def test_curve_process(self):
        """Given an image, perform the easing function on the values
        in the image.
        """
        exp = [[
            [0x10, 0x81, 0xca, 0xf0, 0xfd, 0xff],
            [0x10, 0x81, 0xca, 0xf0, 0xfd, 0xff],
            [0x10, 0x81, 0xca, 0xf0, 0xfd, 0xff],
            [0x10, 0x81, 0xca, 0xf0, 0xfd, 0xff],
            [0x10, 0x81, 0xca, 0xf0, 0xfd, 0xff],
        ],]
        before = [[
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
        ],]
        filter = filters.Curve('io3')
        act = test_filter_process(filter, before)
        self.assertListEqual(exp, act)


class CutLightTestCase(ut.TestCase):
    def test_process_cut_light(self):
        """Given an image, remove every gray below 50% and then
        adjust the remaining grays to fill the whole gamut.
        """
        exp = [[
            [0x80, 0xff, 0xff, 0xff, 0xff, 0xff],
            [0x80, 0xff, 0xff, 0xff, 0xff, 0xff],
            [0x80, 0xff, 0xff, 0xff, 0xff, 0xff],
            [0x80, 0xff, 0xff, 0xff, 0xff, 0xff],
            [0x80, 0xff, 0xff, 0xff, 0xff, 0xff],
        ],]
        before = [[
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
        ],]
        filter = filters.CutLight(threshold=.5)
        act = test_filter_process(filter, before)
        self.assertListEqual(exp, act)


class CutShadowTestCase(ut.TestCase):
    def test_process_cut_shadow(self):
        """Given an image, remove every gray below 50% and then
        adjust the remaining grays to fill the whole gamut.
        """
        exp = [[
            [0x00, 0x00, 0x01, 0x81, 0xff,],
            [0x00, 0x00, 0x01, 0x81, 0xff,],
            [0x00, 0x00, 0x01, 0x81, 0xff,],
            [0x00, 0x00, 0x01, 0x81, 0xff,],
            [0x00, 0x00, 0x01, 0x81, 0xff,],
        ],]
        before = [[
            [0x00, 0x40, 0x80, 0xc0, 0xff,],
            [0x00, 0x40, 0x80, 0xc0, 0xff,],
            [0x00, 0x40, 0x80, 0xc0, 0xff,],
            [0x00, 0x40, 0x80, 0xc0, 0xff,],
            [0x00, 0x40, 0x80, 0xc0, 0xff,],
        ],]
        filter = filters.CutShadow(threshold=.5)
        act = test_filter_process(filter, before)
        self.assertListEqual(exp, act)

    def test_process_cut_shadow_in_out_cubic(self):
        """Given an image, remove every gray below 50% and then
        adjust the remaining grays to fill the whole gamut using
        an in-out cubic easing function.
        """
        exp = [[
            [0x00, 0x00, 0x11, 0x84, 0xf0, 0xff],
            [0x00, 0x00, 0x11, 0x84, 0xf0, 0xff],
            [0x00, 0x00, 0x11, 0x84, 0xf0, 0xff],
            [0x00, 0x00, 0x11, 0x84, 0xf0, 0xff],
            [0x00, 0x00, 0x11, 0x84, 0xf0, 0xff],
        ],]
        before = [[
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
        ],]
        filter = filters.CutShadow(threshold=.5, ease='io3')
        act = test_filter_process(filter, before)
        self.assertListEqual(exp, act)

    def test_process_cut_shadow_in_quint(self):
        """Given an image, remove every gray below 50% and then
        adjust the remaining grays to fill the whole gamut using
        an in-out cubic easing function.
        """
        exp = [[
            [0x00, 0x00, 0x00, 0x08, 0x3f, 0xff],
            [0x00, 0x00, 0x00, 0x08, 0x3f, 0xff],
            [0x00, 0x00, 0x00, 0x08, 0x3f, 0xff],
            [0x00, 0x00, 0x00, 0x08, 0x3f, 0xff],
            [0x00, 0x00, 0x00, 0x08, 0x3f, 0xff],
        ],]
        before = [[
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            [0x40, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
        ],]
        filter = filters.CutShadow(threshold=.5, ease='i5')
        act = test_filter_process(filter, before)
        self.assertListEqual(exp, act)


class FlipTestCase(ut.TestCase):
    def test_motionblur_process(self):
        """Given an image, perform the easing function on the values
        in the image.
        """
        exp = [
            [
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            ],
            [
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            ],
        ]
        kwargs = {
            'direction': 'h',
        }
        filter = filters.Flip(**kwargs)
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class GaussianBlurTestCase(ut.TestCase):
    def test_gaussianblur_process(self):
        """Given an image, perform a gaussian blur on the image.
        """
        exp = [
            [
                [0xa8, 0xa8, 0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xac],
                [0xa8, 0xa8, 0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xac],
                [0xa8, 0xa8, 0xa9, 0xa9, 0xaa, 0xaa, 0xab, 0xab, 0xab],
                [0xa9, 0xa9, 0xa9, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0xab],
                [0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa],
                [0xab, 0xab, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0xa9, 0xa9],
                [0xab, 0xab, 0xab, 0xaa, 0xaa, 0xa9, 0xa9, 0xa8, 0xa8],
                [0xac, 0xac, 0xab, 0xab, 0xaa, 0xa9, 0xa8, 0xa8, 0xa8],
                [0xac, 0xac, 0xab, 0xab, 0xaa, 0xa9, 0xa8, 0xa8, 0xa8],
            ],
            [
                [0xa8, 0xa8, 0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xac],
                [0xa8, 0xa8, 0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xac],
                [0xa8, 0xa8, 0xa9, 0xa9, 0xaa, 0xaa, 0xab, 0xab, 0xab],
                [0xa9, 0xa9, 0xa9, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0xab],
                [0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa],
                [0xab, 0xab, 0xaa, 0xaa, 0xaa, 0xaa, 0xa9, 0xa9, 0xa9],
                [0xab, 0xab, 0xab, 0xaa, 0xaa, 0xa9, 0xa9, 0xa8, 0xa8],
                [0xac, 0xac, 0xab, 0xab, 0xaa, 0xa9, 0xa8, 0xa8, 0xa8],
                [0xac, 0xac, 0xab, 0xab, 0xaa, 0xa9, 0xa8, 0xa8, 0xa8],
            ],
        ]
        kwargs = {
            'sigma': 5,
        }
        filter = filters.GaussianBlur(**kwargs)
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class GlowTestCase(ut.TestCase):
    def test_glow_process(self):
        """Given an image, perform a series of gaussian blurs on the
        image, blending them together with a screen operation to create
        a glow effect.
        """
        exp = [
            [
                [0xa5, 0xb6, 0xcc, 0xdf, 0xed, 0xf7, 0xfc, 0xfe, 0xff],
                [0xb6, 0xc5, 0xd8, 0xe8, 0xf3, 0xfa, 0xfe, 0xff, 0xfe],
                [0xcc, 0xd8, 0xe7, 0xf2, 0xf9, 0xfd, 0xff, 0xfe, 0xfc],
                [0xdf, 0xe8, 0xf2, 0xf9, 0xfd, 0xff, 0xfd, 0xfa, 0xf7],
                [0xed, 0xf3, 0xf9, 0xfd, 0xff, 0xfd, 0xf9, 0xf3, 0xed],
                [0xf7, 0xfa, 0xfd, 0xff, 0xfd, 0xf9, 0xf2, 0xe8, 0xdf],
                [0xfc, 0xfe, 0xff, 0xfd, 0xf9, 0xf2, 0xe7, 0xd8, 0xcc],
                [0xfe, 0xff, 0xfe, 0xfa, 0xf3, 0xe8, 0xd8, 0xc5, 0xb6],
                [0xff, 0xfe, 0xfc, 0xf7, 0xed, 0xdf, 0xcc, 0xb6, 0xa5],
            ],
            [
                [0xa5, 0xb6, 0xcc, 0xdf, 0xed, 0xf7, 0xfc, 0xfe, 0xff],
                [0xb6, 0xc5, 0xd8, 0xe8, 0xf3, 0xfa, 0xfe, 0xff, 0xfe],
                [0xcc, 0xd8, 0xe7, 0xf2, 0xf9, 0xfd, 0xff, 0xfe, 0xfc],
                [0xdf, 0xe8, 0xf2, 0xf9, 0xfd, 0xff, 0xfd, 0xfa, 0xf7],
                [0xed, 0xf3, 0xf9, 0xfd, 0xff, 0xfd, 0xf9, 0xf3, 0xed],
                [0xf7, 0xfa, 0xfd, 0xff, 0xfd, 0xf9, 0xf2, 0xe8, 0xdf],
                [0xfc, 0xfe, 0xff, 0xfd, 0xf9, 0xf2, 0xe7, 0xd8, 0xcc],
                [0xfe, 0xff, 0xfe, 0xfa, 0xf3, 0xe8, 0xd8, 0xc5, 0xb6],
                [0xff, 0xfe, 0xfc, 0xf7, 0xed, 0xdf, 0xcc, 0xb6, 0xa5],
            ],
        ]
        kwargs = {
            'start_sigma': 4,
        }
        filter = filters.Glow(**kwargs)
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class MotionBlurTestCase(ut.TestCase):
    def test_motionblur_process(self):
        """Given an image, perform the easing function on the values
        in the image.
        """
        exp = [
            [
                [0x20, 0x20, 0x30, 0x50, 0x70, 0x90, 0xb0, 0xd0, 0xe0],
                [0x40, 0x40, 0x50, 0x70, 0x90, 0xb0, 0xd0, 0xe0, 0xf0],
                [0x60, 0x60, 0x70, 0x90, 0xb0, 0xd0, 0xe0, 0xe0, 0xe0],
                [0x80, 0x80, 0x90, 0xb0, 0xd0, 0xe0, 0xe0, 0xd0, 0xc0],
                [0xa0, 0xa0, 0xb0, 0xd0, 0xe0, 0xe0, 0xd0, 0xb0, 0xa0],
                [0xc0, 0xc0, 0xd0, 0xe0, 0xe0, 0xd0, 0xb0, 0x90, 0x80],
                [0xe0, 0xe0, 0xe0, 0xe0, 0xd0, 0xb0, 0x90, 0x70, 0x60],
                [0xf0, 0xf0, 0xe0, 0xd0, 0xb0, 0x90, 0x70, 0x50, 0x40],
                [0xe0, 0xe0, 0xd0, 0xb0, 0x90, 0x70, 0x50, 0x30, 0x20],
            ],
            [
                [0x20, 0x20, 0x30, 0x50, 0x70, 0x90, 0xb0, 0xd0, 0xe0],
                [0x40, 0x40, 0x50, 0x70, 0x90, 0xb0, 0xd0, 0xe0, 0xf0],
                [0x60, 0x60, 0x70, 0x90, 0xb0, 0xd0, 0xe0, 0xe0, 0xe0],
                [0x80, 0x80, 0x90, 0xb0, 0xd0, 0xe0, 0xe0, 0xd0, 0xc0],
                [0xa0, 0xa0, 0xb0, 0xd0, 0xe0, 0xe0, 0xd0, 0xb0, 0xa0],
                [0xc0, 0xc0, 0xd0, 0xe0, 0xe0, 0xd0, 0xb0, 0x90, 0x80],
                [0xe0, 0xe0, 0xe0, 0xe0, 0xd0, 0xb0, 0x90, 0x70, 0x60],
                [0xf0, 0xf0, 0xe0, 0xd0, 0xb0, 0x90, 0x70, 0x50, 0x40],
                [0xe0, 0xe0, 0xd0, 0xb0, 0x90, 0x70, 0x50, 0x30, 0x20],
            ],
        ]
        kwargs = {
            'size': 4,
            'direction': 'h',
        }
        filter = filters.MotionBlur(**kwargs)
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class PinchTestCase(ut.TestCase):
    def test_processing(self):
        """The Pinch filter distorts the image as though the center
        point is being pulled back from the viewer.
        """
        exp = [
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0x9f, 0xbc, 0xde, 0xfe, 0xe0, 0xc0],
                [0x60, 0x80, 0x9f, 0xb4, 0xcc, 0xf0, 0xe0, 0xbf, 0xa0],
                [0x80, 0xa0, 0xbc, 0xcc, 0xd8, 0xe0, 0xb6, 0x9e, 0x80],
                [0xa0, 0xc0, 0xde, 0xf0, 0xe0, 0x98, 0x8c, 0x7c, 0x60],
                [0xc0, 0xe0, 0xfe, 0xe0, 0xb6, 0x8c, 0x74, 0x5f, 0x40],
                [0xe0, 0xff, 0xe0, 0xbf, 0x9e, 0x7c, 0x5f, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0x9f, 0xbc, 0xde, 0xfe, 0xe0, 0xc0],
                [0x60, 0x80, 0x9f, 0xb4, 0xcc, 0xf0, 0xe0, 0xbf, 0xa0],
                [0x80, 0xa0, 0xbc, 0xcc, 0xd8, 0xe0, 0xb6, 0x9e, 0x80],
                [0xa0, 0xc0, 0xde, 0xf0, 0xe0, 0x98, 0x8c, 0x7c, 0x60],
                [0xc0, 0xe0, 0xfe, 0xe0, 0xb6, 0x8c, 0x74, 0x5f, 0x40],
                [0xe0, 0xff, 0xe0, 0xbf, 0x9e, 0x7c, 0x5f, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
        ]
        filter = filters.Pinch('.75', '16', '5,5,5')
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class PolarToLinearTestCase(ut.TestCase):
    def test_preprocessing(self):
        """The PolarToLinear filter needs the image to be square, so
        PolarToLinear.preprocessing should return a square size.
        """
        # Expected value.
        exp = (2, 8, 8)

        # Set up test data and state.
        size = [2, 5, 8]
        obj = filters.PolarToLinear()

        # Run test.
        act = obj.preprocess(size)

        # Determine if test passed.
        self.assertTupleEqual(exp, act)

    def test_postrocessing(self):
        """The PolarToLinear filter needs the image to be square, so
        PolarToLinear.postprocessing should remove the padding added
        by preprocessing from the given size.
        """
        # Expected value.
        exp = (2, 5, 8)

        # Set up test data and state.
        size = [2, 8, 8]
        obj = filters.PolarToLinear()
        obj.padding = tuple(s - e for s, e in zip(size, exp))

        # Run test.
        act = obj.postprocess(size)

        # Determine if test passed.
        self.assertTupleEqual(exp, act)

    def test_processing(self):
        """The PolarToLinear filter maps the given array a polar
        coordinates and then interprets those coordinates as linear
        coordinates, returning the transformed image.
        """
        exp = [
            [
                [0x80, 0xa0, 0xc0, 0xe0, 0xe0, 0xff, 0x00, 0x00, 0x00],
                [0x80, 0xa0, 0xc0, 0xc0, 0xe0, 0xe0, 0xff, 0xff, 0x00],
                [0x80, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x00, 0x00, 0x00],
                [0x80, 0x80, 0x80, 0x60, 0x60, 0x60, 0x40, 0x00, 0x00],
                [0x80, 0x80, 0x60, 0x60, 0x40, 0x20, 0x20, 0x00, 0x00],
                [0x80, 0x80, 0x60, 0x60, 0x40, 0x20, 0x20, 0x00, 0x00],
                [0x80, 0x80, 0x80, 0x60, 0x60, 0x60, 0x40, 0x40, 0x40],
                [0x80, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x00],
                [0x80, 0xa0, 0xc0, 0xc0, 0xe0, 0xe0, 0xff, 0xff, 0x00],
            ],
            [
                [0x80, 0xa0, 0xc0, 0xe0, 0xe0, 0xff, 0x00, 0x00, 0x00],
                [0x80, 0xa0, 0xc0, 0xc0, 0xe0, 0xe0, 0xff, 0xff, 0x00],
                [0x80, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x00, 0x00, 0x00],
                [0x80, 0x80, 0x80, 0x60, 0x60, 0x60, 0x40, 0x00, 0x00],
                [0x80, 0x80, 0x60, 0x60, 0x40, 0x20, 0x20, 0x00, 0x00],
                [0x80, 0x80, 0x60, 0x60, 0x40, 0x20, 0x20, 0x00, 0x00],
                [0x80, 0x80, 0x80, 0x60, 0x60, 0x60, 0x40, 0x40, 0x40],
                [0x80, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0x00],
                [0x80, 0xa0, 0xc0, 0xc0, 0xe0, 0xe0, 0xff, 0xff, 0x00],
            ],
        ]
        before = [
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            ],
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            ],
        ]
        filter = filters.PolarToLinear()
        act = test_filter_process(filter, before)
        self.assertListEqual(exp, act)


class ResizeTestCase(ut.TestCase):
    def test_preprocessing(self):
        """The Resize filter allows the size of the image generated to
        be different than the final image size. Resize.preprocessing
        should return the size of the image to generate.
        """
        # Expected value.
        exp = (2, 8, 8)

        # Set up test data and state.
        size = [2, 5, 8]
        obj = filters.Resize(exp)

        # Run test.
        act = obj.preprocess(size)

        # Determine if test passed.
        self.assertTupleEqual(exp, act)

    def test_postrocessing(self):
        """The Resize filter allows the size of the image generated to
        be different than the final image size, so Resize.postprocessing
        should remove the padding added by preprocessing from the given size.
        """
        # Expected value.
        exp = (2, 5, 8)

        # Set up test data and state.
        size = [2, 8, 8]
        obj = filters.Resize(size)
        obj.padding = tuple(s - e for s, e in zip(size, exp))

        # Run test.
        act = obj.postprocess(size)

        # Determine if test passed.
        self.assertTupleEqual(exp, act)

    def test_processing_when_image_is_cropped(self):
        """When the generated image will be cropped rather than
        resized, Resize.process should return the given image
        without change.
        """
        # Expected values.
        exp = [
            [
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
            ],
            [
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0,],
            ],
        ]

        # Set up test data and state.
        a = np.array([
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            ],
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
            ],
        ], dtype=np.float32)
        a = a / 0xff
        size = (2, 7, 7)
        new_size = (2, 9, 9)
        crop = 'true'
        obj = filters.Resize(new_size, crop)
        filters_ = [obj,]
        _ = filters.preprocess(size, filters_)

        # Run test.
        result = filters.postprocess(a, filters_)

        # Extract actual values.
        result = np.around(result * 0xff).astype(int)
        act = result.tolist()

        # Determine if test passed.
        self.assertListEqual(exp, act)

    def test_processing_when_image_is_resized(self):
        """When the generated image will be resized rather than
        cropped, Resize.process should resize the image before
        returning it and clear its padding attribute. Clearing the
        padding attribute is needed to prevent the size from being
        changed again during postprocessing.
        """
        # Expected values.
        exp = [
            [
                [0x00, 0x1b, 0x38, 0x55, 0x72, 0x8e, 0xab, 0xc8, 0xe5, 0xff],
                [0x11, 0x2c, 0x49, 0x66, 0x83, 0xa0, 0xbc, 0xd9, 0xf0, 0xee],
                [0x27, 0x43, 0x5f, 0x7c, 0x99, 0xb6, 0xd3, 0xeb, 0xf3, 0xd9],
                [0x3e, 0x59, 0x76, 0x92, 0xaf, 0xcc, 0xe8, 0xf6, 0xde, 0xc2],
                [0x54, 0x6f, 0x8c, 0xa8, 0xc5, 0xe2, 0xf1, 0xe4, 0xc8, 0xac],
                [0x6a, 0x85, 0xa2, 0xbf, 0xdb, 0xef, 0xeb, 0xce, 0xb1, 0x96],
                [0x80, 0x9b, 0xb8, 0xd5, 0xf1, 0xf1, 0xd5, 0xb8, 0x9b, 0x80],
                [0x96, 0xb1, 0xce, 0xeb, 0xef, 0xdb, 0xbf, 0xa2, 0x85, 0x6a],
                [0xac, 0xc8, 0xe4, 0xf1, 0xe2, 0xc5, 0xa8, 0x8c, 0x6f, 0x54],
                [0xc2, 0xde, 0xf6, 0xe8, 0xcc, 0xaf, 0x92, 0x76, 0x59, 0x3e],
                [0xd9, 0xf3, 0xeb, 0xd3, 0xb6, 0x99, 0x7c, 0x5f, 0x43, 0x27],
                [0xee, 0xf0, 0xd9, 0xbc, 0xa0, 0x83, 0x66, 0x49, 0x2c, 0x11],
                [0xff, 0xe5, 0xc8, 0xab, 0x8e, 0x72, 0x55, 0x38, 0x1b, 0x00],
            ],
            [
                [0x00, 0x1b, 0x38, 0x55, 0x72, 0x8e, 0xab, 0xc8, 0xe5, 0xff],
                [0x11, 0x2c, 0x49, 0x66, 0x83, 0xa0, 0xbc, 0xd9, 0xf0, 0xee],
                [0x27, 0x43, 0x5f, 0x7c, 0x99, 0xb6, 0xd3, 0xeb, 0xf3, 0xd9],
                [0x3e, 0x59, 0x76, 0x92, 0xaf, 0xcc, 0xe8, 0xf6, 0xde, 0xc2],
                [0x54, 0x6f, 0x8c, 0xa8, 0xc5, 0xe2, 0xf1, 0xe4, 0xc8, 0xac],
                [0x6a, 0x85, 0xa2, 0xbf, 0xdb, 0xef, 0xeb, 0xce, 0xb1, 0x96],
                [0x80, 0x9b, 0xb8, 0xd5, 0xf1, 0xf1, 0xd5, 0xb8, 0x9b, 0x80],
                [0x96, 0xb1, 0xce, 0xeb, 0xef, 0xdb, 0xbf, 0xa2, 0x85, 0x6a],
                [0xac, 0xc8, 0xe4, 0xf1, 0xe2, 0xc5, 0xa8, 0x8c, 0x6f, 0x54],
                [0xc2, 0xde, 0xf6, 0xe8, 0xcc, 0xaf, 0x92, 0x76, 0x59, 0x3e],
                [0xd9, 0xf3, 0xeb, 0xd3, 0xb6, 0x99, 0x7c, 0x5f, 0x43, 0x27],
                [0xee, 0xf0, 0xd9, 0xbc, 0xa0, 0x83, 0x66, 0x49, 0x2c, 0x11],
                [0xff, 0xe5, 0xc8, 0xab, 0x8e, 0x72, 0x55, 0x38, 0x1b, 0x00],
            ],
        ]
        exp_padding = [0, 0, 0]

        # Set up test data and state.
        a = np.array([
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
            [
                [0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff],
                [0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0],
                [0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0],
                [0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0],
                [0x80, 0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80],
                [0xa0, 0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60],
                [0xc0, 0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40],
                [0xe0, 0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20],
                [0xff, 0xe0, 0xc0, 0xa0, 0x80, 0x60, 0x40, 0x20, 0x00],
            ],
        ])
        a = a / 0xff
        new_size = (2, 9, 9)
        crop = 'false'
        original_size = np.array(exp).shape
        obj = filters.Resize(new_size, crop)
        _ = obj.preprocess(original_size)

        # Run test.
        result = obj.process(a)

        # Extract actual values.
        result = np.around(result * 0xff).astype(int)
        act = result.tolist()
        act_padding = obj.padding

        # Determine if test passed.
        self.assertListEqual(exp, act)
        self.assertListEqual(exp_padding, act_padding)


class RippleTestCase(ut.TestCase):
    def test_processing(self):
        """The Ripple filter distorts the image as though waves were
        running through the image.
        """
        exp = [
            [
                [0x44, 0x20, 0x00, 0x00, 0x00, 0xa0, 0xfb, 0xc0, 0xbc],
                [0x64, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xdc, 0xa0, 0x9c],
                [0x84, 0x60, 0x38, 0x00, 0x70, 0xe0, 0xbc, 0x80, 0x7c],
                [0xa4, 0x80, 0x5c, 0x60, 0x9c, 0xff, 0x9c, 0x60, 0x5c],
                [0xc4, 0xa0, 0x7c, 0x80, 0xbc, 0xe0, 0x7c, 0x40, 0x3c],
                [0xe4, 0xc0, 0x9c, 0xa0, 0xdc, 0xc0, 0x5c, 0x20, 0x1c],
                [0xdf, 0xe0, 0xbc, 0xc0, 0xfb, 0xa0, 0x38, 0x00, 0x00],
                [0x00, 0xff, 0xdc, 0xe0, 0xe4, 0x80, 0x00, 0x00, 0x00],
                [0x00, 0xe0, 0xfb, 0xff, 0xc4, 0x60, 0x00, 0x00, 0x00],
            ],
            [
                [0x44, 0x20, 0x00, 0x00, 0x00, 0xa0, 0xfb, 0xc0, 0xbc],
                [0x64, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xdc, 0xa0, 0x9c],
                [0x84, 0x60, 0x38, 0x00, 0x70, 0xe0, 0xbc, 0x80, 0x7c],
                [0xa4, 0x80, 0x5c, 0x60, 0x9c, 0xff, 0x9c, 0x60, 0x5c],
                [0xc4, 0xa0, 0x7c, 0x80, 0xbc, 0xe0, 0x7c, 0x40, 0x3c],
                [0xe4, 0xc0, 0x9c, 0xa0, 0xdc, 0xc0, 0x5c, 0x20, 0x1c],
                [0xdf, 0xe0, 0xbc, 0xc0, 0xfb, 0xa0, 0x38, 0x00, 0x00],
                [0x00, 0xff, 0xdc, 0xe0, 0xe4, 0x80, 0x00, 0x00, 0x00],
                [0x00, 0xe0, 0xfb, 0xff, 0xc4, 0x60, 0x00, 0x00, 0x00],
            ],
        ]
        filter = filters.Ripple('0,8,8','0,3.0,3.0', 'cross', '0,1,1')
        act = test_filter_process(filter)
        self.assertListEqual(exp, act)


class Rotate90TestCase(ut.TestCase):
    def test_rotate90_preprocessing(self):
        """The rotation filter only works if the image is a square
        during the rotation. So, when given X and Y axes that are
        not equal in size, return a new size where the X and Y axes
        are equal and store how much padding the filter added, and
        on which axis.
        """
        exp_size = (4, 128, 1280, 1280)
        exp_stored = (0, 0, 560, 0)

        size = (4, 128, 720, 1280)
        f = filters.Rotate90('r')
        act_size = f.preprocess(size)
        act_stored = f.padding

        self.assertTupleEqual(exp_size, act_size)
        self.assertEqual(exp_stored, act_stored)

    def test_rotate90_postprocessing(self):
        """When given an image size, reverse any padding that had
        been previous done, returning the new size.
        """
        exp = (4, 128, 720, 1280)

        size = (4, 128, 1280, 1280)
        f = filters.Rotate90('r')
        f.padding = (0, 0, 560, 0)
        act = f.postprocess(size)

        self.assertTupleEqual(exp, act)

    def test_rotate90_rotate_right(self):
        """Given the colors of an image, rotate that image 90Â° in
        the direction set on the filter."""
        exp = [
            [
                [3, 1],
                [4, 2],
            ],
            [
                [7, 5],
                [8, 6],
            ],
        ]

        values = np.array([
            [
                [1, 2],
                [3, 4],
            ],
            [
                [5, 6],
                [7, 8],
            ],
        ])
        f = filters.Rotate90('r')
        new = f.process(values)
        act = new.tolist()

        self.assertListEqual(exp, act)


class SkewTestCase(ut.TestCase):
    def test_skew_preprocess(self):
        """Skewing the image leaves artifacts on the edge of the image.
        Given the current size of the image and the original size of
        the image, return a size that has been padded to prevent the
        artifacts from appearing in the final image, and store the
        amount of padding added.
        """
        exp_size = (6, 128, 5, 9)
        exp_padding = (0, 0, 0, 2)

        original_size = (6, 128, 5, 5)
        size = (6, 128, 5, 7)
        slope = 1
        f = filters.Skew(slope)
        act_size = f.preprocess(size, original_size)
        act_padding = f.padding

        self.assertEqual(exp_padding, act_padding)
        self.assertTupleEqual(exp_size, act_size)

    def test_skew_slope_1(self):
        """Given the colors in the image, skew the Y axis with a slope
        of 1, returning the new image.
        """
        exp = [
            [
                [1, 2],
                [4, 3],
            ],
            [
                [5, 6],
                [8, 7],
            ],
        ]

        values = np.array([
            [
                [1, 2],
                [3, 4],
            ],
            [
                [5, 6],
                [7, 8],
            ],
        ])
        f = filters.Skew(1)
        new = f.process(values)
        act = new.tolist()

        self.assertListEqual(exp, act)


# Processing tests.
class ProcessTestCase(ut.TestCase):
    def test_preprocess_layer_filters(self):
        """Given the list of filters and an image size, filters.process
        should run the preprocessing for each image and return the new
        image size.
        """
        # Expected value.
        exp = (6, 128, 9, 9)

        # Set up test data and state.
        size = (6, 128, 5, 5)
        fs = [
            filters.Skew(1),
            filters.Rotate90('r'),
        ]

        # Run test.
        act = filters.preprocess(size, fs)

        # Determine if test passed.
        self.assertTupleEqual(exp, act)

    def test_postprocess_layer_filters(self):
        """Given a list of filters and an image, remove any padding
        the filters added to the image and return the new image.
        """
        # Expected value.
        exp = [
            [
                [0x5, 0x6],
                [0x9, 0xA],
            ],
            [
                [0x5, 0x6],
                [0x9, 0xA],
            ],
        ]

        # Set up test data and state.
        a = np.array([
            [
                [0x0, 0x1, 0x2, 0x3],
                [0x4, 0x5, 0x6, 0x7],
                [0x8, 0x9, 0xA, 0xB],
                [0xC, 0xD, 0xE, 0xF],
            ],
            [
                [0x0, 0x1, 0x2, 0x3],
                [0x4, 0x5, 0x6, 0x7],
                [0x8, 0x9, 0xA, 0xB],
                [0xC, 0xD, 0xE, 0xF],
            ],
        ])
        filters_ = [
            filters.Skew(1),
            filters.Rotate90('r'),
        ]
        filters_[0].padding = (0, 0, 2)
        filters_[1].padding = (0, 2, 0)

        # Run test.
        result = filters.postprocess(a, filters_)

        # Extract test results.
        act = result.tolist()

        # Determine if test passed.
        self.assertListEqual(exp, act)

    def test_process_layer_filters(self):
        """Given a list of filters and an image, filters.process
        should perform the filters on the image and return the
        image.
        """
        # Expected value.
        exp = [
            [
                [4, 1],
                [3, 2],
            ],
            [
                [8, 5],
                [7, 6],
            ],
        ]

        # Set up test data and state.
        a = np.array([
            [
                [1, 2],
                [3, 4],
            ],
            [
                [5, 6],
                [7, 8],
            ],
        ])
        filters_ = [
            filters.Skew(1),
            filters.Rotate90('r'),
        ]

        # Run test.
        result = filters.process(a, filters_)

        # Extract test results.
        act = result.tolist()

        # Determine if test passed.
        self.assertListEqual(exp, act)
