"""
test_pjinoise
~~~~~~~~~~~~~

Unit tests for the core image generation of the pjinoise module.
"""
import unittest as ut

import numpy as np

from pjinoise import pjinoise as pn
from pjinoise import sources as s
from pjinoise.constants import X, Y, Z


# Utility classes.
class Source(s.ValueSource):
    def __init__(self, *args, **kwargs) -> None:
        self.image = np.array([
            [
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
            ],
            [
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
                [0x00, 0x40, 0x80, 0xc0, 0xff,],
            ],
        ]).astype(int)
        self.scale = 0xff
        self.size = self.image.shape
    
    def fill(self, size, loc, *args, **kwargs):
        a = self.image.astype(float) / self.scale
        if loc:
            for axis in X, Y, Z:
                a = np.roll(a, loc[axis], axis=axis)
        if size != self.size:
            begin = [(o - n) // 2 for o, n in zip(self.size, size)]
            end = [b + n for b, n in zip(begin, size)]
            slices = tuple(slice(b, e) for b, e in zip(begin, end))
            a = a[slices]
        return a
        


# Test cases.
class LayerTestCase(ut.TestCase):
    def test_create_image_data_from_valuesource(self):
        """Given a ValueSource and a size, produce an amount of image 
        data equal to size from the given location within the source.
        """
        # Back up currently existing state.
        registered_sources_bkp = s.registered_sources.copy()
        try:
        
            # Set up data for expected values.
            src = Source()
            
            # Expected values.
            exp = src.image.tolist()
            
            # Set up test data and state.
            size = src.size
            
            # Run test.
            result = pn.render_source(src, size)
            
            # Extract actual data from the test.
            a = np.around(result * src.scale).astype(int)
            act = a.tolist()
            
            # Determine if test passed.
            self.assertListEqual(exp, act)
        
        # Restore the original state.
        finally:
            s.registered_sources = registered_sources_bkp
    
    def test_create_image_data_with_location(self):
        """If a location is given, the image data should be offset 
        by that location when generated by the ValueSource.
        """
        # Back up currently existing state.
        registered_sources_bkp = s.registered_sources.copy()
        try:
        
            # Set up data for expected values.
            src = Source()
            
            # Expected values.
            exp = [
                [
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                ],
                [
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                    [0x40, 0x80, 0xc0, 0xff, 0x00],
                ],
            ]
            
            # Set up test data and state.
            size = src.size
            location = [0, 0, -1]
            
            # Run test.
            result = pn.render_source(src, size, location)
            
            # Extract actual data from the test.
            a = np.around(result * src.scale).astype(int)
            act = a.tolist()
            
            # Determine if test passed.
            self.assertListEqual(exp, act)
        
        # Restore the original state.
        finally:
            s.registered_sources = registered_sources_bkp
    
    